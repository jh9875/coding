처음엔 간단히 재귀로 해봤다.
근데 답은 맞게나오는것같은데.. 수의 범위가 꽤 넓으니 시간초과는 당연하다..
그래서 다른사람이 쓴 글을 보고 풀어봤다.
동적프로그래밍으로 하는데 정말 만든사람은 대단한것같다.
실행연산의 횟수를 엄청나게 줄이면서 효과적으로 나타낼수있다는거에 놀랐다.
코드내용도 짧다. 내용을 보면 아래와같다
int[] dp =new int[1000001];
		dp[1] =0;
		dp[2] =1;
		for(int i =3; i <dp.length; i++)
		{
			dp[i] =dp[i-1] +1;		//dp는 방법의 수인데, 전보다 한번더연산을 하므로.
			if(i %3 ==0)
				dp[i] =Math.min(dp[i/3] +1, dp[i]);
			if(i %2 ==0)
				dp[i] =Math.min(dp[i/2] +1, dp[i]);
		}
		int n =input.nextInt();
		System.out.println(dp[n]);
일단 이 내용은 (https://noinkim.tistory.com/20) 여기서 참고했다.
여기서 dp[인덱스]가 의미하는건 "인덱스번째의 최소연산횟수"이다.
그럼 예를 살펴보면 일단

1. dp[1] =0이다.
이 문제가 1로 만들기 위한거니까 1이 됬으니까 연산이 0번 필요하다.

2. dp[2] =1이다.
 2에서 1을 빼던지, 2에서 2를 나누던지 연산횟수는 1이니 dp[2]는 1이된다.

3. i =3일때 보면
반복문 안에 들어서는데
첫줄 dp[i] =dp[i-1] +1;가 의미하는건 1을 빼는연산이다. 1을빼는 연산은
1번의 연산으로 생각하므로 바로 전단계에서 1을 더해주는것이다.
밑에는 2개의 if문이 있다.
이건 1을 빼는 연산과 2와 3으로 나누는 연산중 최소한의 연산을 저장하기 위한
것이다.
i는 3일때 첫번째 조건에 만족한다.
그럼 dp[i/3]+1과 dp[i-1]+1을 비교하게된다.
dp[0]은 0이고 dp[2]는 1이므로 dp[3]은 dp[i/3]+1 =1이 된다.
이런식으로 최소한의 연산의 데이터값을 쌓아가는것이다.

4. i =6일때를 보면
dp[5] +1 =4, dp[2]+1 =2, dp[3]+1 =2중에 택하게된다.
그럼 dp[6]은 2가되낟.

5. 마지막으로 i =10일때를 보자
첫번째 식에서 dp[10] =dp[9] +1 =3이된다.
밑에 if문들을 보면 i%2가 조건을 만족한다.
그럼 dp[10] =dp[5] +1 =4가된다.
이중 최솟값은 3이므로 dp[10] =3이된다.

이런식으로 최소한의 연산만을 하며 횟수를 dp에 저장하면 중복계산하는 일을
크게 줄일수 있다..
앞으로 dp문제를 많이 풀어 연습해야할 필요를 느낀다..