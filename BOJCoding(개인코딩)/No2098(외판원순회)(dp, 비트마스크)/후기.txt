백준온라인저지에 왼판원순회1과 2가 있다.

왼판원순회2는 도시의 범위가2~10이기 때문에 완전탐색으로 해결할수있다.

그러나 외판원순회1은 도시의 범위가 2~16이라서 완전탐색으로 풀면

시간초과가 난다.

그래서 다른방법을 써봤다.



사용한 방법은 동적계획법이다.

동적계획법을 사용하기 위해서 비트마스크도 써봤다.

완전탐색으로 코드를 짤땐 방문한 위치들을 확인하는것을 boolean배열로 확인했다.

그러나 메모이제이션을 쓰기 위해선 데이터의 형태를 바꿔줬어야 됐는데,

비트마스크를 쓰면 가능했다.

수를 이진수로 바꿔볼때 각 방문한 위치의 자릿수를 1로 만들고, 아니면 0으로 하면 된다.

만약 모든도시를 방문했다면 수가 N만큼 1이 있을것이다.

ex) N==4일때 ...0000001111

이런식으로 기저사례를 작성했다.

그리고 탐색할때 방문한 곳인지 아닌지 확인하기 위해서

&연산을 사용했다.

if((visited & (1 <<next)) >0) continue;

이런식으로 방문한 위치면 건너 뛰도록 했다.

위 코드가 나타내는것은 visited는 현재 방문한 위치들인데 next번째 도시를 확인하기 위해

해당 자릿수가 0이면 &연산을 하면 0을 반환하고 아니면 해당자릿수 수를 int형으로 반환한다.



그리고 햇갈렸던 부분이 2가지 정도가 있었다.

첫번째
모든경우의 시작위치를 생각해줘야 되는줄 알았다.

근데 다른사람 코드를 보니 모두 0에서 출발하는게 아닌가?

그래서 인터넷에 찾아봤다.

생각해보니까 모든 도시를 순회하려면 반드시 0번도시를 거쳐야 한다.

최소경로니까 어디가 시작점이든 상관 없었던 것이다.

두번째
답을 계속 틀려서 다른사람 코드랑 비교해봤더니 마지막 기저사례에서

이동가능한 경로를 확인했어야했는데 그걸 확인하지 못했다.

W[here][0] ==0이면 이동 불가여서 INF값을 반환했어야 했다.


이 문제를 통해 비트마스크를 배웠는데, 동적계획법을 사용할때 유용한 방법인것 같다.