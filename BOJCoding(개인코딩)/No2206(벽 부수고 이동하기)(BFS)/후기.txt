문제를 보고 bfs탐색해서 끝까지 가는 최단경로를 생각했다.

벽을 부수는 것은 한번 부수면 boolean 자료형을 이용해서 한번 부수면 true로 하고

아직 부수지 않았으면 false로 해서 확인했다.

그런데 틀렸다. 메모리초과다.

혹시나 하는 마음에 int형 배열로 받은 맵을 byte로 바꿔봤다.

그래도 틀렸다.

알고리즘의 변화가 필요함을 느꼈다.

아마도 방문한 위치들을 queue에 너무 많이 넣어서 메모리 초과가 일어난것같다.

그렇지만 내가 평소에 하던 boolean[][] 배열을 이용하면 모든 경우를 탐색할수 없다.

이미 지나간 길을 다시 queue에 넣지 않으면서 모든 길을 탐색할 수 있는 새로운 방법이 필요하다.

-----

그래서 추가해본 방법이

visited를 boolean이차원 배열이 아니라 int형 이차원 배열로 해본것이다.

만약 visited[curY][curX] 보다 visited[nextY][nextX] 가 크다면 이전에 방문했던 곳일것 같아서

다음 방문할 곳이 더 적게 방문한 곳이면 queue에 넣도록 했다.

결론은 실패다.

-------

그래서 결국 다른사람들의 풀이를 봤다.

근데 다른사람들은 visited배열을 3차원으로 했다.

왜그럴까 생각하고 봤는데

visited에서 1,2차원은 y,x좌표이고 나머지 한개는 벽을 부순횟수?이다.

내가 전에 풀었던 풀이는 좌표와 경로의 합만 있는 구조체를 이용해서 풀었는데

문제는 이미 지나간 곳을 다시 queue에 넣어서 메모리초과가 나오는 문제가 있었다.

그리고 생각해보면 벽을 한번 부쉰것을 map에 표시해야 되는것 같다.

객체에만 한번 부순것을 표시하면 다시 지나갈때?(최단경로를 찾을때 다시 지나갈 일이 있을까
생각이 든다.) 막혀버린다.

그래서 visited라는 2차원 배열로 다시 방문하지 않도록 했지만

어떤 경우를 고려하지 못하는 부분이 생겼다.

3차원 배열로 했을때에는

벽을 부쉰곳을 표시할 수 있고, 이미 지나간 길도 다시 안가도 된다.
