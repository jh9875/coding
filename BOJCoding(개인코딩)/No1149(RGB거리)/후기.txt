첫번째 시도는 나름 dp를 생각해서 첫번째에서 최솟값을 찾고
그 다음부터는 전 색깔과는 다르게 선택하면서 둘중에 최소를 선택해 가면서 하도록 했다.
근데 생각해보니까 굳이 첫번째 최소를 안고르더라도 되는것같다..

그래서 두번째 시도는 dp를 2차원 배열로 만들어서 dp[n][0]은 R로 시작할때,
dp[n][1]은 G로 시작할때 이런식으로 했다. 근데 틀렸다..

다른사람꺼를 참조해서 보니

알고리즘은 이러했다
for(int i =1; i <n; i++)
{
	dp[i][0] =Math.min(dp[i-1][1], dp[i-1][2]) +arr[i][0];
	dp[i][1] =Math.min(dp[i-1][0], dp[i-1][2]) +arr[i][1];
	dp[i][2] =Math.min(dp[i-1][0], dp[i-1][1]) +arr[i][2];
}
약간의 미묘한 차이가 있다.

내가 두번째로 했던 방법은 dp[i][0], dp[i][1], dp[i][2]가 각각 RGB로 시작할때
에[i][n]이 최소가 될수있게 하는거였는데 방법이 예를들어 dp[n][0]은 R로 시작할때
색이 이웃하지 않게 최솟값들만을 저장하는거였는데

다른사람껄 참조해서보니
예를드어 dp[n][0]은 arr[n][0]만을 더하는데 여기에 dp[n][1], dp[n][2]중
최소를 더하는 방식이다. 즉 dp[n][k]는 k색만을 n번째에 k색깔을 선택하는것이다..?

두번째 했던 방법이 왜 틀린걸까..?