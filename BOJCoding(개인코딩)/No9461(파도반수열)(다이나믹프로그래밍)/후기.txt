일단 문제 유형이 동적계획법이라 해서 어떤방식으로 나누고 데이터를 저장할까 고민했었다...
어떻게 풀까 고민하다가 일단 수를 다 나열해보았다. 문제에 나온 예제 외에도 그 뒤에 이어서
데이터를 더 써보다가 규칙을 찾았다.
어떤 데이터의 인덱스가 i라고 할때 i의 값은 i-1번째와 i-5번째 값이 합쳐져서 나온값이다.
도형을 보니 이것이 규칙적으로 나타나서 점화식이 금방나왔다.

배열의 초기 5개 값은 
1 1 1 2 2이고
6번째 값부터
for(int i =6; i <101; i++)
	arr[i] =arr[i-1] +arr[i-5];
로 하면 정답이다.
다만 처음 풀이했는데 틀려서 이유를 찾아보니까. 수가 많이 증가해서 int의 범위를 초과해서
틀렸다.

근데 이걸 동적계획법으로 푼게 맞나 의심이 들어서 다른 코드를 찾아봤다.
대부분 위 방법과 비슷하게 하긴 했는데 동적계획법 같이? 한 코드를 찾았다.
완전탐색 + 메모이제이션 방법을 이용한것같다.
풀이는 두번째 풀이에 있다.

근데 예상외로 두번째 풀이의 시간이 더 적게들었다.
거의 비슷하게 나오긴했는데 미세하게 두번째 풀이의 시간이 더 적게들었다.
