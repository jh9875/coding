런타임 에러가 한참떠서 뭐가 이유인지 몰랐는데 지금 생각해보니까
(num-1 >=0 && !visited[num-1]) 이렇게 범위를 확인했어야 했는데,
(!visited[num-1] && num-1 >=0) 이렇게해서 배열범위를 벗어나서
런타임에러가 났었다...

그리고 첫번째 시도는 중복된 방문은 피할려고 했는데, 피하면 모든 경로를 탐색못하게
되서 실패하는것같다.

그래서 결국 다른분꺼를 참조해봤다.
다른사람은 dp? 비슷한 개념으로 푼것같다.
이 디렉토리 안에있는 직접이라는 이미지에 테스트 해본결과와 같다.
0~100000까지 범위의 int배열을 선언해주고
어떤 수를 거쳐갈때 이동횟수(이 문제에서의 시간)의 누적값을 저장한다.
예를들어 n에서 n-1로 이동하면 한번더 이동하는것이므로 visit[n]에서 1을 더해준다.
visit[n-1] =visit[n] +1;

근데 의문이 드는게 다른사람꺼 참조한것도 visit[n-1] ==0 이러한 조건을줘서
이미 거쳐간곳은 생략했는데 왜 첫번째 시도는 틀린건지 잘 모르겠다...