문제를 읽어보면 4보다 큰 짝수중 두 홀수 소수의 합으로 찾는 문제였다.

처음 읽고 떠오른 알고리즘은 이중 for문으로 값을 하나씩 찾아보는것이었다.

두 수의 차이가 커야 하므로 다음과같이 코드를 썼다.

for(int i =3; i <n; i++)
{
	if(!isPrime[i])
		continue;
	for(int j =n-1; j >2; j--)
	{
		if(!isPirme[j])
			continue;
		...
	}
}

저렇게하고 값을 찾은다음 종료를 하면 원하는 값이 나온다.

그런데 너무 단순하게 문제를 생각했다.

역시 시간초과가 났다.

그래서 최적화하기위해서 코드를 훑어봤다.

일단 위 문장에서는 i가 3부터 4, 5, 6이런식진행된다.

근데 생각해보면 (2이상의) 짝수는 무조건 소수가 아니기때문에 넘기면 됐다.

그래서 위에서 i++대신 i+=2를 해줬다.

그래도 똑같았다.

그래서 백준 게시판에서 문제에대한 팁을 얻었는데

그중 눈에띄었던 팁중 하나는

n을 이루는 두 수의 합중 하나가 n1이라고하고, 나머지를 n2라고 하면

n =n1+n2니까

n1이 정해지면 n2 =n -n1이었다.

그럼 for문이 1개만 있으면 되니까 알고리즘 효율이 크게 올라간다

나는 이 방법을 다음과같이 구현했다.

for(n1 =3; n1 <n; n1+=2)
{
	if(!isPrime[n1])
		continue;
	n2 =n-n1;
	if(!isPrime[n2])
		continue;
				
	bw.write(n +" = " +n1 + " + " +n2 +"\n");
	check =true;
	break;
}
if(!check)
	bw.write("Goldbach's conjecture is wrong.\n");

위에서 bw.write(n +" = " +n1 + " + " +n2 +"\n");는 값을 찾으면 기록하고 종료한다.

밑에 있는것은 못찾았을 경우 정해진 문자열을 출력한다.


위의 방법을 이용해서
문제의 시간복잡도를 O(N^2)에서 O(N)으로 줄였다.