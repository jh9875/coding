이 문제를 다른사람꺼 참고 안하고 풀어서 상당히 기쁘다.

암튼 내가 생각해낸 아이디어는 이렇다.

예제를 보자면 배열arr에
10 20 10 30 20 50이 있다.
"가장 긴 증가하는 부분 수열" 을 구하는 문제인데
dp의 원리를 이용해 구한 데이터를 여러번 이용하기 위해서
'뒤'에서부터 탐색을 해보았다.

그럼 상황을 그려보자면
인덱스/배열      10 20 10 30 20 50
        1	       
        2
        3
        4
        5
        6
처음의 상황은 이렇다.
이제 뒤에서 부터 본인보다 큰수를 선택하면서 길이가 가장 긴 것을 선택면
위 배열은 다음과 같이 채워진다.

인덱스/배열      10 20 10 30 20 50
        1	                              X
        2                          50 50  X
        3                 30  20  
        4                 50  50
        5            20
        6	      30
	      50
대충 그리면 위와같다.
중요한것은 그 전에 있는 데이터를 활용한다는 것이다.
배열의 제일 처음요서 10이 활용한 데이터는 두번째 데이터 20의 가장 긴부분 20 30 50
부분이다. 이걸 10에 붙여서 10 20 30 50 이 된것이다.
그럼 두번째 데이터 20이 활용한 데이터는 네번째 데이터 30 50이다. 이걸 두번째 데이터에
붙여서 20 30 50이 된것이다.
순서를 걱정할 필요가 없는데 어짜피 뒤에서부터 검사하기 때문에 상관없다.

이제 본론으로 들어가서 저 데이터들을 일일히 다 복사하면서 붙여넣을 필요가 없다.
이 문제에서 알고싶은것은 가장 길게 증가하는 수열의 길이이다.

즉 알고리즘은 각 이중 for문에서 뒤에서부터 검사하는데 각 배열 i는 뒤에있는배열중에
본인보다 크면서(증가하는) 증가하는 부분이 긴걸 더해주면 되는것이다.
코드는 아래와 같다.

for(int i =N-1; i >=0; i--)
{
	int bestLen =0;
	for(int j =i+1; j <N; j++)
	{
		if((arr[i] <arr[j]))
		{
			if(dp[j] >bestLen)
				bestLen =dp[j];
		}
	}			dp[i] +=bestLen;
}

