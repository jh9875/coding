처음에 생각난건 단순하게 G보다 낮으면 현재 위치에서 U만큼 더해주고

G보다 높으면 현재 위치보다 D만큼 낮춰주면 되고,

boolean배열의 visited로 중복된 길을 안가게 하면 되는줄 알았다.

생각해보니

만약 가야하는 층이 10층인데 현재 9층이고, U =2, D =1이라면

1층 내려가고 2층 올라가야 하는 상황이 온다.

이런 경우가 일어날 경우 위의 알고리즘으론 해결되지 않는다.

즉 모든 경우를 다 찾으면서 최단경로를 찾아야 한다.



알고리즘은 위 아래로 가능할 경우 queue에 넣어주고 경로를 찾는다. 못찾으면 특정한 수를
반환해 use the stairs를 출력하게 했다.



예전엔 몰랐는데 bfs문제를 풀다보니 이 알고리즘은 최단경로 문제를 풀때 자주 이용되는것같다.