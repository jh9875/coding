처음엔 그냥 풀던대로 동적계획법을 이용해서 풀었다.

시간초과가 나서 어디가 잘못된건지 살펴보다가 문제의 입력 크기를 봤더니

1000000이었다.

동적계획법으로 했을때 알고리즘의 시간복잡도가 O(N^2)이니 시간초과다.

그래서 도저히 모르겠어서 인터넷에 검색해봤다.

찾아보니 대부분 이분탐색을 이용한 알고리즘을 이용했다.

오름차순 수열을 찾아야 하기 때문에 가능한 문제이다.

입력 수들을 차례대로 list에 넣는데, list의 제일 마지막수(제일 큰수)보다 크면

마지막에 추가해서 넣어준다.

작다면 여기서부터 이분탐색으로 중간에 넣어주는데 덮어씌우는 식이다.

왜 그런지는 머리로는 이해가 안되지만.... 손으로 그려보니까.

list가 최대 길이의 수열을 만들어 준다.

알고리즘의 핵심부분은 아래와 같다.

if(list.get(list.size()-1) <value)
	list.add(value);
else
{
	int l, r, m;
	l =0; r =list.size()-1;
				
	while(l <r)
	{
		m =(l+r)/2;
		if(list.get(m) <value)
			l =m+1;
		else
			r =m;
	}
	list.set(r, value);
}


