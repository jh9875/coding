전에 배웠던 dp? 메모이제이션을 좀 써먹은것같다.
처음인것같다 구글링 안하고 동적프로그래밍 문제를 풀어본것을
전에 비슷한 문제를 풀었어서 기억이 났다.
연속합을 구하는 문제인데 메모이제이션을 이용하면 된다.
근데 내가 처음에 했을때는 간신히 통과했다..
통과후 다른사람들은 나보더 훨씬더 적은시간이 걸려서 소스를 봤다.
내가 사용한 방법은 아래와 같이
int max =dp[0];
		for(int i =0; i <dp.length; i++)
		{
			if(max <dp[i])
				max =dp[i];
			for(int j =0; j <i; j++)
			{
				int num =dp[i] -dp[j];
				if(max <num)
					max =num;
			}
		}
이중for문을 이용해서 시간이 오래걸렸다. 통과하기는 했다
근데 다른사람 코드를 보니 아래처럼
for(int i =1; i <n; i++)
		{
			dp[i] =Math.max(arr[i], dp[i-1]+arr[i]);

			if(dp[i] >max)
				max =dp[i];
		}
for문을 1개만 써서 더욱더 효율적으로 알고리즘을 짰다.
시간은 놀라울만큼 차이가 많이났다.
약 10배 차이다.
for문이 1개 더있어서 그런것같다.
for문이 1개면 O(n)인데 반해 이중for문이면 O(n2)이 들어서 10배인가보다..
아직 이것까지 소화는 바라지 않지만 점점 익숙해지면서 효율적으로 짜는 방법을 습득해야한다.
