재귀적동적계획법으로 풀려고 해도 감이 안잡혔다.

그래서 문제를 풀때 많이 헤맸다.

아무튼 재귀적 동적계획법 풀이를 써보자면

함수이름을 solve라고 하자.

모든 경우의 수를 세어야 하므로 반환형은 int로 하자.

동전의 합이 k가 된경우 1을 반환하고, 아닌경우는 0을 반환하는 기저사례를 함수의
처음에 만들어야 한다.

그리고 파라미터를 동전들의 합이랑 동전 index값으로 한다.

static int solve(int index, int value);

이 문제에서 동전이 중복으로 들어가는 것을 허용한다.

그렇지만 동전의 값은 1이상이기 때문에 index가 증가하지 않아도 숫자 한개로만 채울수도 있다.

예를들어 동전의 값어치가 1인경우 이 동전으로만채워도 1가지 경우가 된다.

여기서 동전의 구성은 같고 순서가 다른경우를 고려해야한다.

중복을 제거하려면 순서를 강제로 만드는 방법이 있다.

나는 다음과 같이 코드를 짰다.

for(int i =index; i <=n; i++)
	cache[index][value] +=solve(i, value +coin[i]);

현재 index보다 같거나 큰값들만 호출하면 중복경우가 없어진다.

여기서 cache[코인의 index값][전체 value]

2차원 int배열을 만들어 중복계산을 없앨수있다.

성공 후 다른사람들의 시간과 메모리를 보니 내가 한것보다 더 적게들었다.

동적계획법에는 재귀적동적계획법과 반복적 동적계획법이 있는데

반복적 동적계획법을 이용함으로써 얻을 수 있는 장점중 하나는

슬라이딩 윈도우 기법을 이용함으로써 메모리 절약을 할 수 있다.

나는 재귀함수를 이용해서 푸는게 직관적이고 코딩을 공부하는 중이라 이 방법을 쓰는중이다.

================================================

다른사람들의 반복적 동적계획법 코드를 보고 따라해봤다.

좀 이해하기 어려웠지만 시간과 메모리 둘다 절약할 수 있었다.