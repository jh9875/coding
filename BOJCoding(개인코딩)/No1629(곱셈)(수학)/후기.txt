아주 예전에 코딩을 거의 안했을때 무작정 for문으로 곱하다가 틀렸었다.

그러다 최근에 분할정복을 배운 이후로 이 문제를 다시 풀어봤는데 틀렸다.

일단 테스트케이스가 맞게 나와서 맞을줄 알았는데 시간초과가 나왔다.

왜그럴까? 생각을 해봤다.


일단 내가 처음 제출했던 코드는 다음과 같다.

static long pow(int n)
{
	if(n ==1)
		return A %C;
	if(n %2 ==1)
		return pow(n-1) *A %C;
	else
		return pow(n/2)*pow(n/2) %C;
}

두번째 제출한 코드는 다음과 같다.

static long pow(int b)
{
	if(b ==1)
		return A %C;
	if(b %2 ==1)
		return pow(b-1) *A %C;
	long half =pow(b /2) %C;
	
	return half *half %C;
}

두 코드는 비슷해 보이지만 사소한차이가 있다.

바로 첫번째는 n이 짝수일때 pow를 2번 호출하지만
두번째는 n이 짝수일때 pow를 한번 호출한 결과를 가지고 곱하기 연산만 한다.

이게 생각해보니까 계산해야 되는 나머지 절반을 없앤것이나 마찬가지이다.



만약 for문으로 곱하는 알고리즘이라면 시간복잡도가 O(N)이다.

나쁜편은 아니지만 입력이 20억이 넘어가서 O(N)으론 힘들어보인다.

하지만 분할정복으로 문제를 해결한다면 O(logN)으로 줄어든다.