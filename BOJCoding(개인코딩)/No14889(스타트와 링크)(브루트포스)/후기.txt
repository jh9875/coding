확실히 머릿속에 트리를 그릴줄 알면 알고리즘을 푸는데 유용한것같다.

이 문제도 트리를 그려서 맞췄다.

재귀함수 형태로 반만 boolean배열을 true로 만들어서
level이 N/2에 도달하면 그때가서 능력치를 종합해봐서 차이가 최소가 되게끔 하게했다.

처음 풀었던 방법에서는 boolean배열을 함수를 호출할 때마다 새로 만들고 복사해서
메모리를 많이 낭비했다.

그래서 재귀호출 방식을 약간 수정해봤다.

알고리즘을 간단하게 나타내본다면 아래와 같다.

for(int i =index+1; i <N; i++)
{
	if(!visited[i])
	{
		visited[i] =true;
		pickTeam1(i, count+1);
		visited[i] =false;
	}			
}

visited를 전역변수로 선언하고 모든 경우의 수가 이 배열을 통해 저장된다.

true로 하고 다시 false로 바꿔놓으면 일일히 다 복사할 필요가 없어진다.