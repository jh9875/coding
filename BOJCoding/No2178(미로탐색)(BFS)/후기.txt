오랜만에 BFS하는거라 겁먹었었다.
BFD는 Breadth First Search로서
가까이 있는것들 부터 우선탐색하는것이다.
구글에서 이 알고리즘을 여러번 보다보니 이해가 갔다.
BFS는 queue를 이용하는데 다음에 이동할 것을 queue에 넣고
이동을 실행할때 poll해서 뺀다. 그리고 이동한 자리에서 넣을수있는게 있으면
queue에 넣어준다.
즉, queue에 들어가는 것들은 이동 가능한 것들이다.
이것을 이해하고는 구현은 잘 됬다.
근데 여기서 최단경로를 구하는게 문제였다.
해답은 구글링에 있었다.
갈때마다 배열에 이동 숫자를 업데이트 시켜주는것이었다.
현재 위치에서 다음 이동할 위치를 현재값 +1을 시켜주는것이다.
(현재위치를 map[p.x][p.y]라고 한다면, map[p.x +1][p.y] =map[p.x][p.y] +1
를 해주고 다음위치들도 같은값을 해준다. 그럼 최단경로가 된다.)
문제는 풀었는데 내가 짠 코드를 보니 너무 비효율 적으로 했다는 생각이 든다.
나는 아래, 오른쪽, 위, 왼쪽을 일일히 다 코드로 썼는데, 다른사람이 한것을 보면
static int[] dx = { -1, 0, 1, 0 };
static int[] dy = { 0, -1, 0, 1 };
이렇게 다음 이동할 크기를 배열로 만들었다.
그리고 탐색할때는
for (int i = 0; i < 4; i++) {
                //다음 방문할 좌표 nextX, nextY
                int nextX = d.x + dx[i];
                int nextY = d.y + dy[i];
이렇식으로 for로 돌아가면서 했다.
만약 다음 미로찾기가 있다면 이렇게 시도해보자.