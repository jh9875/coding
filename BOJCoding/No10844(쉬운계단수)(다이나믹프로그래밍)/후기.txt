일단 이 문제를 처음 완전탐색으로 풀어봤다.
1%도 못가고 시간초과가 났다.

그래서 동적계획법으로 풀어봤다.

코드에서 중요한 부분은 다음과 같다.
int[][] dp 라는 배열이 있는데
여기서 행이 나타내는것은 자릿수이고
열이 나타내는것을 그 자리에 들어갈 숫자다.

밑으로 내려갈수록 자릿수가 증가하고 가능한 가짓수가 더해진다.

dp[1][i](i는 1~9)는 다 1이다.

이제 이걸 이용해서 2번째 자리부터 연산을 하면 된다.

for(int i =2; i <=N; i++)
{
	for(int j =0; j <10; j++)
	{
		if(j ==0)
			dp[i][j] =dp[i-1][j+1];
		else if(j ==9)
			dp[i][j] =dp[i-1][j-11];
		else
			dp[i][j] =(dp[i-1][j-1] +dp[i-1][j+1])%MOD;
	}
}

여기서 j가 10까지 가능한 이유는 2째 자리부터는 0~9까지 모두 가능하기 때문이다.
그리고 j==0과 j==9를 따로 처리한 이유는 그 다음에 나올 수 있는 경우가 1가지이기 때문이다.